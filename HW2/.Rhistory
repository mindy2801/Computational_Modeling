temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
mmle_model_optim[[]]
mmle_model_optim
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
mle_model_optim
rm(list=ls())  # clear workspace
set.seed(08826)  # set a seed number for replication
source("MLE.R")   # source MLE.R code
##########################
## General Setup        ##
## Data and Parameters  ##
##########################
n_total <- 50 # sample size
t_int <- c(0.5, 1, 2, 4, 8, 12, 16, 18) # time interval values
n_corr <- c(44, 34, 27, 26, 19, 17, 20, 11) # number of correct responses
p_corr <- n_corr/n_total # proportion correct
# Generate random uniform numbers between 0 and 1 to use as initials for the optim procedure
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
##########################
## MLE                  ##
##########################
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
#mle_model_pow1 <- optim(param1_init, mle_pow1, method="L-BFGS-B", lower=param_pow1_low, upper=param_pow1_up, int=t_int, n=n_total, x=n_corr)
# Try many different inits to escape from the local maxima
for (i in 1:100) {
param1_init <- runif(1); param2_init <- runif(2); param3_init <- runif(3);
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
rm(list=ls())  # clear workspace
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
##########################
## MLE                  ##
##########################
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
#mle_model_pow1 <- optim(param1_init, mle_pow1, method="L-BFGS-B", lower=param_pow1_low, upper=param_pow1_up, int=t_int, n=n_total, x=n_corr)
# Try many different inits to escape from the local maxima
for (i in 1:100) {
param1_init <- runif(1); param2_init <- runif(2); param3_init <- runif(3);
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
rm(list=ls())  # clear workspace
n_total <- 50 # sample size
t_int <- c(0.5, 1, 2, 4, 8, 12, 16, 18) # time interval values
n_corr <- c(44, 34, 27, 26, 19, 17, 20, 11) # number of correct responses
p_corr <- n_corr/n_total # proportion correct
# Generate random uniform numbers between 0 and 1 to use as initials for the optim procedure
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
##########################
## MLE                  ##
##########################
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
#mle_model_pow1 <- optim(param1_init, mle_pow1, method="L-BFGS-B", lower=param_pow1_low, upper=param_pow1_up, int=t_int, n=n_total, x=n_corr)
# Try many different inits to escape from the local maxima
for (i in 1:100) {
param1_init <- runif(1); param2_init <- runif(2); param3_init <- runif(3);
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
rm(list=ls())  # clear workspace
n_total <- 50 # sample size
t_int <- c(0.5, 1, 2, 4, 8, 12, 16, 18) # time interval values
n_corr <- c(44, 34, 27, 26, 19, 17, 20, 11) # number of correct responses
p_corr <- n_corr/n_total # proportion correct
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
rm(list=ls())  # clear workspace
set.seed(08826)  # set a seed number for replication
source("MLE.R")   # source MLE.R code
n_total <- 50 # sample size
t_int <- c(0.5, 1, 2, 4, 8, 12, 16, 18) # time interval values
n_corr <- c(44, 34, 27, 26, 19, 17, 20, 11) # number of correct responses
p_corr <- n_corr/n_total # proportion correct
# Generate random uniform numbers between 0 and 1 to use as initials for the optim procedure
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
##########################
## MLE                  ##
##########################
# Call general purpose optimization rountine
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
#mle_model_pow1 <- optim(param1_init, mle_pow1, method="L-BFGS-B", lower=param_pow1_low, upper=param_pow1_up, int=t_int, n=n_total, x=n_corr)
# Try many different inits to escape from the local maxima
for (i in 1:100) {
param1_init <- runif(1); param2_init <- runif(2); param3_init <- runif(3);
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
# Save the MLE parameter estimates
param_model <- list()
for (model in 1:7){
param_model[[model]] <- mle_model_optim[[model]]
rm(list=ls())  # clear workspace
set.seed(08826)  # set a seed number for replication
source("MLE.R")   # source MLE.R code
rm(list=ls())  # clear workspace
graphics.off() # close all figures
rm(list=ls())  # clear workspace
rm(list=ls())  # clear workspace
rm(list=ls())  # clear workspace
rm(list=ls())  # clear workspace
set.seed(08826)  # set a seed number for replication
source("MLE.R")   # source MLE.R code
n_total <- 50 # sample size
t_int <- c(0.5, 1, 2, 4, 8, 12, 16, 18) # time interval values
n_corr <- c(44, 34, 27, 26, 19, 17, 20, 11) # number of correct responses
p_corr <- n_corr/n_total # proportion correct
# Generate random uniform numbers between 0 and 1 to use as initials for the optim procedure
param1_init <- runif(1)
param2_init <- runif(2)
param3_init <- runif(3)
param_pow1_low <- c(0); param_pow1_up <- c(3);
param_pow2_low <- c(0, 0); param_pow2_up <- c(1, 3);  # lower and upper bounds of POW2 model (0<a<1, 0<b<3)
param_exp1_low <- c(0); param_exp1_up <- c(3);
param_exp2_low <- c(0, 0); param_exp2_up <- c(1, 3);  # lower and upper bounds of EXP2 model (0<a<1, 0<b<3)
param_expow_low <- c(0, 0, -Inf); param_expow_up <- c(1, Inf, 3);
param_hyp1_low <- c(0); param_hyp1_up <- c(1);
param_hyp2_low <- c(0, 0); param_hyp2_up <- c(1, 1);
param_low <- list(param_pow1_low, param_pow2_low, param_exp1_low, param_exp2_low, param_expow_low, param_hyp1_low, param_hyp2_low)
param_up <- list(param_pow1_up, param_pow2_up, param_exp1_up, param_exp2_up, param_expow_up, param_hyp1_up, param_hyp2_up)
##########################
## MLE                  ##
##########################
mle_model <- c(mle_pow1, mle_pow2, mle_exp1, mle_exp2, mle_expow, mle_hyp1, mle_hyp2)
mle_model_optim <- list()
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
for (model in 1:7){
mle_model_optim[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
}
# Try many different inits to escape from the local maxima
for (i in 1:100) {
param1_init <- runif(1); param2_init <- runif(2); param3_init <- runif(3);
init <- list(param1_init, param2_init, param1_init, param2_init, param3_init, param1_init, param2_init)
temp_model <- list()
for (model in 1:7){
temp_model[[model]] <- optim(init[[model]], mle_model[[model]], method="L-BFGS-B", lower=param_low[[model]], upper=param_up[[model]], int=t_int, n=n_total, x=n_corr)
# Replace the results if the latest optimization yields better result
if(temp_model[[model]]$value < mle_model_optim[[model]]$value) mle_model_optim[[model]] <- temp_model[[model]]
}
}
# Save the MLE parameter estimates
param_model <- list()
for (model in 1:7){
param_model[[model]] <- mle_model_optim[[model]]
}
param_model[[3]]
# Save the MLE parameter estimates
param_model <- list()
for (model in 1:7){
param_model[[model]] <- mle_model_optim[[model]]$par
}
param_model[[1]]
param_model[[2]]
param_model[[3]]
param_model[[4]]
param_model[[5]]
mle_model_optim[[1]]$value
mle_model_optim[[3]]$value
mle_model_optim[[2]]$value
mle_model_optim[[5]]$value
# Compute AIC = -2*log(lik) + 2*K
AIC <- function(n_par=c(), mle_model_optim=list()){
values <- c()
for (model in 1:7){
values[model] <- 2*mle_model_optim[[model]]$value + 2*n_par[model]
}
}
# Compute AIC = -2*log(lik) + 2*K
AIC <- function(n_par=c(), mle_model_optim=list()){
values <- c()
for (model in 1:7){
values[model] <- 2*mle_model_optim[[model]]$value + 2*n_par[model]
}
values
}
AIC(c(1,2,1,2,3,1,2), mle_model_optim)
# number of parameters (k_modelName)
n_par <- c(1,2,1,2,3,1,2)
# number of data points (N)
N = length(p_corr)
AIC(n_par, mle_model_optim)
names = c("POW1","POW2","EXP1", "EXP2", "EXPOW", "HYP1", "HYP2")
all_AIC <- AIC(n_par, mle_model_optim)
all_BIC <- BIC(n_par, N, mle_model_optim)
# Compute BIC = -2*log(lik) + K*log(N)
BIC <- function(n_par=c(), N, mle_model_optim=list()){
values <- c()
for (model in 1:7){
values[model] <- 2*mle_model_optim[[model]]$value + n_par[model]*log(N)
}
values
}
all_BIC <- BIC(n_par, N, mle_model_optim)
names = c("POW1","POW2","EXP1", "EXP2", "EXPOW", "HYP1", "HYP2")
modelcomp_summary = data.frame(Models = names, AIC = all_AIC, BIC = all_BIC)
modelcomp_summary
print(modelcomp_summary)
data <- read.table("ra_exampleData.txt", header=T)
data
head(data)
N = unique(subjID)  # number of subjects
N = unique(data$subjID)  # number of subjects
n
N
?read,table
?read.table
data <- read.table("ra_exampleData.txt", header=T, stringsAsFactors = "subjID")
data <- read.table("ra_exampleData.txt", header=T); data$subjID <- factor(subjID)
data <- read.table("ra_exampleData.txt", header=T); data$subjID <- factor(data$subjID)
head(data)
str(data)
T = with(data, length(data[subjID==2, outcome])) # number of trials per subject
data[data$subjID==2, data$outcome]
data[,"subjID"]
data[,subjID]
with(data,data[,subjID])
data["subjID"==2,"outcome"]
data[data$subjID==2,"outcome"]
T = length(data[data$subjID==2,"outcome"]) # number of trials per subject
data <- read.table("ra_exampleData.txt", header=T); attach(data)
rm(ls=list())
rm=(list=ls())
ls()
rm=(list=ls())
rm(list=lis())
rm(list=ls())
data <- read.table("ra_exampleData.txt", header=T); attach(data)
head(data)
cert
head(data)
ra_prospect <- function(param=c("rho", "tau", "lambdda"), T=140, data=raw_data){
attach(raw_data)
for (t in 1:T) {
#evSafe: expected value of a certain (safe) option
#evGamble: expected value of a risky option (gamble)
#pGamble   # probability of choosing a gamble on each trial
# free parameters: rho, tau, lambda
rho <- param[1]; tau <- param[2]; lambda <- param[3]
evSafe   = cert[t]^rho
evGamble = 0.5*(gain[t]^rho - lambda*abs(loss[t])^rho)
pGamble  = 1 / (1 + exp(tau*(evSafe - evGamble)))
pGamble  = pGamble * 0.9998 + 0.0001  # to make its range between 0.0001 and 0.9999
tmp_minusLL   = -log(pGamble)*gamble[t] - log(1-pGamble)*(1-gamble[t])  # LL of trial t
sum_minusLL   = sum_minusLL + tmp_minusLL
}
}
?optim
# for a single subject=2
sub2_data <- data[subjID==2,]
ra_prospect <- function(param=c("rho", "tau", "lambdda"), T=140, data=raw_data){
attach(raw_data)
sum_minusLL = 0  # sum of minus log likelihood. Initialize
for (t in 1:T) {
#evSafe: expected value of a certain (safe) option
#evGamble: expected value of a risky option (gamble)
#pGamble   # probability of choosing a gamble on each trial
# free parameters: rho, tau, lambda
rho <- param[1]; tau <- param[2]; lambda <- param[3]
evSafe   = cert[t]^rho
evGamble = 0.5*(gain[t]^rho - lambda*abs(loss[t])^rho)
pGamble  = 1 / (1 + exp(tau*(evSafe - evGamble)))
pGamble  = pGamble * 0.9998 + 0.0001  # to make its range between 0.0001 and 0.9999
tmp_minusLL   = -log(pGamble)*gamble[t] - log(1-pGamble)*(1-gamble[t])  # LL of trial t
sum_minusLL   = sum_minusLL + tmp_minusLL
}
}
N = length(unique(data$subjID))  # number of subjects
T = length(data[data$subjID==2,"outcome"]) # number of trials per subject
rho <- par_init[1]; tau <- par_init[2]; lambda <- par_init[3]
par_init <- runif(3)
rho <- par_init[1]; tau <- par_init[2]; lambda <- par_init[3]
bound_low <- c(0, 0, 0); bound_up <- c(2, 5, 10)
temp_model <- optim(par_init, ra_prospect, param=par_init, T=T, data=subj_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
temp_model <- optim(par_init, ra_prospect, param=par_init, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
ra_prospect(par_init, T=T, data=sub2_data)
ra_prospect <- function(param=c("rho", "tau", "lambdda"), T=140, data=raw_data){
attach(data)
sum_minusLL = 0  # sum of minus log likelihood. Initialize
for (t in 1:T) {
#evSafe: expected value of a certain (safe) option
#evGamble: expected value of a risky option (gamble)
#pGamble   # probability of choosing a gamble on each trial
# free parameters: rho, tau, lambda
rho <- param[1]; tau <- param[2]; lambda <- param[3]
evSafe   = cert[t]^rho
evGamble = 0.5*(gain[t]^rho - lambda*abs(loss[t])^rho)
pGamble  = 1 / (1 + exp(tau*(evSafe - evGamble)))
pGamble  = pGamble * 0.9998 + 0.0001  # to make its range between 0.0001 and 0.9999
tmp_minusLL   = -log(pGamble)*gamble[t] - log(1-pGamble)*(1-gamble[t])  # LL of trial t
sum_minusLL   = sum_minusLL + tmp_minusLL
}
}
ra_prospect(par_init, T=T, data=sub2_data)
ra_prospect <- function(param=c("rho", "tau", "lambdda"), T=140, data=raw_data){
attach(data)
sum_minusLL = 0  # sum of minus log likelihood. Initialize
for (t in 1:T) {
#evSafe: expected value of a certain (safe) option
#evGamble: expected value of a risky option (gamble)
#pGamble   # probability of choosing a gamble on each trial
# free parameters: rho, tau, lambda
rho <- param[1]; tau <- param[2]; lambda <- param[3]
evSafe   = cert[t]^rho
evGamble = 0.5*(gain[t]^rho - lambda*abs(loss[t])^rho)
pGamble  = 1 / (1 + exp(tau*(evSafe - evGamble)))
pGamble  = pGamble * 0.9998 + 0.0001  # to make its range between 0.0001 and 0.9999
tmp_minusLL   = -log(pGamble)*gamble[t] - log(1-pGamble)*(1-gamble[t])  # LL of trial t
sum_minusLL   = sum_minusLL + tmp_minusLL
}
sum_minusLL
}
ra_prospect(par_init, T=T, data=sub2_data)
ra_prospect(par_init, T=T, data=sub2_data)
?warning
?warning=F
?attach
ra_prospect <- function(param=c("rho", "tau", "lambdda"), T=140, data=raw_data){
attach(data, warn.conflicts = FALSE)
sum_minusLL = 0  # sum of minus log likelihood. Initialize
for (t in 1:T) {
#evSafe: expected value of a certain (safe) option
#evGamble: expected value of a risky option (gamble)
#pGamble   # probability of choosing a gamble on each trial
# free parameters: rho, tau, lambda
rho <- param[1]; tau <- param[2]; lambda <- param[3]
evSafe   = cert[t]^rho
evGamble = 0.5*(gain[t]^rho - lambda*abs(loss[t])^rho)
pGamble  = 1 / (1 + exp(tau*(evSafe - evGamble)))
pGamble  = pGamble * 0.9998 + 0.0001  # to make its range between 0.0001 and 0.9999
tmp_minusLL   = -log(pGamble)*gamble[t] - log(1-pGamble)*(1-gamble[t])  # LL of trial t
sum_minusLL   = sum_minusLL + tmp_minusLL
}
sum_minusLL
}
ra_prospect(par_init, T=T, data=sub2_data)
mle_model <- optim(par_init, ra_prospect, param=par_init, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
mle_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
mle_model
#iteration
for (i in 1:100){
init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
mle_model
#iteration
for (i in 1:100){
init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
#iteration
for (i in 1:10){
init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
mle_model
temp_model
optim(c(4,4,4), ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_upper)
optim(c(4,4,4), ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
mle_model <- optim(c(4,4,4), ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
#iteration
for (i in 1:10){
init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
mle_model
temp_model
optim(c(1,1,0.8), ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
rm(mle_model)
rm(temp_model)
mle_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
mle_model
par_init
#iteration
for (i in 1:10){
par_init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
mle_model
temp_model
#iteration
for (i in 1:50){
par_init <- runif(3)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
temp_model
#iteration
for (i in 1:10){
par_init <- runif(3)*c(2,5,10)
temp_model <- optim(par_init, ra_prospect, T=T, data=sub2_data, method="L-BFGS-B", lower=bound_low, upper=bound_up)
if(temp_model$value <- mle_model$value) mle_model <- temp_model
}
temp_model
ra_prospect
par_init
